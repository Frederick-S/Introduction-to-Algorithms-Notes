<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Problems - Introduction to Algorithms</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Problems";
    var mkdocs_page_input_path = "9-Medians-and-Order-Statistics/Problems.md";
    var mkdocs_page_url = "/9-Medians-and-Order-Statistics/Problems/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="../../mathjaxconfig.js"></script>

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Introduction to Algorithms</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Introduction</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>2 Getting Started</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../2-Getting-Started/2.1-Insertion-sort/">2.1 Insertion sort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../2-Getting-Started/2.2-Analyzing-algorithms/">2.2 Analyzing algorithms</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../2-Getting-Started/2.3-Designing-algorithms/">2.3 Designing algorithms</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../2-Getting-Started/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>3 Growth of Functions</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../3-Growth-of-Functions/3.1-Asymptotic-notation/">3.1 Asymptotic notation</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../3-Growth-of-Functions/3.2-Standard-notations-and-common-functions/">3.2 Standard notations and common functions</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../3-Growth-of-Functions/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>4 Divide and Conquer</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/4.1-The-maximum-subarray-problem/">4.1 The maximum-subarray problem</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/4.2-Strassen's-algorithm-for-matrix-multiplication/">4.2 Strassen's algorithm for matrix multiplication</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/4.3-The-substitution-method-for-solving-recurrences/">4.3 The substitution method for solving recurrences</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/4.4-The-recursion-tree-method-for-solving-recurrences/">4.4 The recursion-tree method for solving recurrences</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/4.5-The-master-method-for-solving-recurrences/">4.5 The master method for solving recurrences</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/4.6-Proof-of-the-master-theorem/">4.6 Proof of the master theorem</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../4-Divide-and-Conquer/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>5 Probabilistic Analysis and Randomized Algorithms</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../5-Probabilistic-Analysis-and-Randomized-Algorithms/5.1-The-hiring-problem/">5.1 The hiring problem</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../5-Probabilistic-Analysis-and-Randomized-Algorithms/5.2-Indicator-random-variables/">5.2 Indicator random variables</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../5-Probabilistic-Analysis-and-Randomized-Algorithms/5.3-Randomized-algorithms/">5.3 Randomized algorithms</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../5-Probabilistic-Analysis-and-Randomized-Algorithms/5.4-Probabilistic-analysis-and-further-uses-of-indicator-random-variables/">5.4 Probabilistic analysis and further uses of indicator random variables</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../5-Probabilistic-Analysis-and-Randomized-Algorithms/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>6 Heapsort</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../6-Heapsort/6.1-Heaps/">6.1 Heaps</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../6-Heapsort/6.2-Maintaining-the-heap-property/">6.2 Maintaining the heap property</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../6-Heapsort/6.3-Building-a-heap/">6.3 Building a heap</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../6-Heapsort/6.4-The-heapsort-algorithm/">6.4 The heapsort algorithm</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../6-Heapsort/6.5-Priority-queues/">6.5 Priority queues</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../6-Heapsort/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>7 Quicksort</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../7-Quicksort/7.1-Description-of-quicksort/">7.1 Description of quicksort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../7-Quicksort/7.2-Performance-of-quicksort/">7.2 Performance of quicksort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../7-Quicksort/7.3-A-randomized-version-of-quicksort/">7.3 A randomized version of quicksort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../7-Quicksort/7.4-Analysis-of-quicksort/">7.4 Analysis of quicksort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../7-Quicksort/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>8 Sorting in Linear Time</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../8-Sorting-in-Linear-Time/8.1-Lower-bounds-for-sorting/">8.1 Lower bounds for sorting</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../8-Sorting-in-Linear-Time/8.2-Counting-sort/">8.2 Counting sort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../8-Sorting-in-Linear-Time/8.3-Radix-sort/">8.3 Radix sort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../8-Sorting-in-Linear-Time/8.4-Bucket-sort/">8.4 Bucket sort</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../8-Sorting-in-Linear-Time/Problems/">Problems</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>9 Medians and Order Statistics</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../9.1-Minimum-and-maximum/">9.1 Minimum and maximum</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../9.2-Selection-in-expected-linear-time/">9.2 Selection in expected linear time</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../9.3-Selection-in-worst-case-linear-time/">9.3 Selection in worst-case linear time</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Problems</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#problems">Problems</a></li>
                
                    <li><a class="toctree-l4" href="#9-1">9-1</a></li>
                
                    <li><a class="toctree-l4" href="#9-2">9-2</a></li>
                
                    <li><a class="toctree-l4" href="#9-3">9-3</a></li>
                
                    <li><a class="toctree-l4" href="#9-4">9-4</a></li>
                
            
            </ul>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>10 Elementary Data Structures</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../10-Elementary-Data-Structures/10.1-Stacks-and-queues/">10.1 Stacks and queues</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../10-Elementary-Data-Structures/10.2-Linked-lists/">10.2 Linked lists</a>
        
    </li>

        
    </ul>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Introduction to Algorithms</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>9 Medians and Order Statistics &raquo;</li>
        
      
    
    <li>Problems</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="problems">Problems</h1>
<h2 id="9-1">9-1</h2>
<h3 id="a">a</h3>
<p>Sorting requires $O(n\lg{n})$, plus $O(i)$ to list the i numbers, the total running time is $O(n\lg{n}) + O(i)$.</p>
<h3 id="b">b</h3>
<p>It requires $O(n)$ to build a max-priority queue, the <code>EXTRACT-MAX</code> costs $O(\lg{n})$, thus the total running time is $O(n) + iO(\lg{n})$.</p>
<h3 id="c">c</h3>
<p>First we need to find the <code>n - i + 1</code> smallest element, this requires O(n). And the array is partitioned around the <code>n - i + 1</code> smallest element. So we need to sort the <code>i - 1</code> numbers, it costs $O((i - 1)\lg{(i - 1)})$, so the total running time is $O(n) + O((i - 1)\lg{(i - 1)})$.</p>
<h2 id="9-2">9-2</h2>
<h3 id="a_1">a</h3>
<p>The median of $x_1, x_2, \ldots, x_n$ is $x_{\lceil \frac{n}{2} \rceil}$. So $\sum_{x_i &lt; x_k} w_i = \frac{1}{n}(\lceil \frac{n}{2} \rceil - 1) &lt; \frac{1}{n}(\frac{n}{2} + 1 - 1) = \frac{1}{2}$. $\sum_{x_i &gt; x_k} w_i = \frac{1}{n}(n - \lceil \frac{n}{2} \rceil) \leq \frac{1}{n}(n - \frac{n}{2}) = \frac{1}{2}$.</p>
<h3 id="b_1">b</h3>
<p>First we sort the elements, and then iterate the sorted elements and sum the corresponding weight, if the sum of weights is bigger than 0.5, then the current element is the weighted median.</p>
<pre><code>WEIGHTED-MEDIAN(A)

SORT(A)
weight-sum = 0
for i = 1 to n
    weight-sum += get weight of A[i]
    if weight-sum &gt;= 0.5:
        return A[i]
</code></pre>

<p>We need $O(n\lg{n})$ to sort all elements, and need O(n) to find the weighted median, the total running time is thus $O(n\lg{n}) + O(n) = O(n\lg{n})$.</p>
<h3 id="c_1">c</h3>
<p>First we get the median of all x, and sum the weights of elements whose value is less than median, and sum the weights of elements whose value is larger than median. If the sum of weights in left part is smaller than 0.5 and the sum of weights in right part is also not larger than 0.5, then the median is weighted median. Otherwise, we do the same procedure on the on the left part if its sum of weights is larger than 0.5, or the right part.</p>
<pre><code>WEIGHTED-MEDIAN(A)

if n = 1
    return A[1]
if n = 2
    if A[1].weight &gt;= A[2].weight
        return A[1]
    else
        return A[2]
else
    median = SELECT(A, MATH.CEIL(A / 2))
    left-weights = 0
    right-weights = 0
    for i = 1 to MATH.CEIL(A / 2) - 1
        left-weights = left-weights + A[i].weight
    for i = MATH.CEIL(A / 2) + 1 to n
        right-weights = right-weights + A[i].weight
    if left-weights &lt; 0.5 and right-weights &lt;= 0.5
        return median
    elseif left-weights &gt;= 0.5
        median.weight = median.weight + right-weights
        A' = { x &lt;= median }
        return WEIGHTED-MEDIAN(A')
    elseif right-weights &gt; 0.5
        median.weight = median.weight + left-weights
        A' = { x &gt;= median }
        return WEIGHTED-MEDIAN(A')
</code></pre>

<p>The recurrence of the algorithm is $T(n) = T(\frac{n}{2}) + \Theta(n)$. Let's solve it by the master method. Here we have a = 1, b = 2, $f(n) = \Theta(n)$. So $\log_b{a} = \log_2{1} = 0$, so $f(n) = \Omega(n^{\log_b{a} + \epsilon})$ for $\epsilon = 0.5$. And $af(\frac{n}{b}) = f(\frac{n}{2}) \leq cf(n)$ for $c = \frac{1}{2}$ and all sufficiently large n, thus $T(n) = \Theta(f(n)) = \Theta(n)$.</p>
<h3 id="d">d</h3>
<p>Let p denotes the weighted median, so $f(p) = \sum_{i = 1}^n w_id(p - p_i) = \sum_{i = 1}^n w_i|p - p_i|$. Since we need to prove the weighted median is the best solution, so for any other point x other than p we should have $f(x) \geq f(p)$, or $f(x) - f(p) \geq 0$.</p>
<p>So $f(x) - f(p) = \sum_{i = 1}^n w_i|x - p_i| - \sum_{i = 1}^n w_i|p - p_i| = \sum_{i = 1}^n w_i(|x - p_i| - |p - p_i|)$.</p>
<p>First let's check the situation when x &lt; p.</p>
<p>When $p_i \leq x &lt; p$, $|x - p_i| - |p - p_i| = x - p_i - (p - p_i) = x - p$, when $x &lt; p_i &lt; p$, $|x - p_i| - |p - p_i| = (p_i - x) - (p - p_i) &gt; 0 - (p - x) = x - p$. When $x &lt; p \leq p_i$, $|x - p_i| - |p - p_i| = p_i - x - (p_i - p) = p - x$.</p>
<p>Thus:</p>
<p>$$
\begin{eqnarray}
\sum_{i = 1}^n w_i(|x - p_i| - |p - p_i|) &amp;&gt;&amp; (x - p)\sum_{p_i &lt; p}w_i + (p - x)\sum_{p_i \geq p}w_i \\
&amp;=&amp; (p - x)(\sum_{p_i \geq p}w_i - \sum_{p_i &lt; p}w_i)
\end{eqnarray}
$$</p>
<p>Because p is weighted median, so $\sum_{p_i \geq p}w_i &gt; \frac{1}{2}$, $\sum_{p_i &lt; p}w_i &lt; \frac{1}{2}$, so $(p - x)(\sum_{p_i \geq p}w_i - \sum_{p_i &lt; p}w_i) &gt; 0$.</p>
<p>Now let's check the situation when x &gt; p.</p>
<p>When $p_i \leq p &lt; x$, $|x - p_i| - |p - p_i| = x - p_i - (p - p_i) = x - p$, when $p &lt; p_i &lt; x$, $|x - p_i| - |p - p_i| = x - p_i - (p_i - p) &gt; 0 - (x - p) = p - x$, when $p &lt; x \leq p_i$, $|x - p_i| - |p - p_i| = p_i - x - (p_i - p) = p - x$.</p>
<p>Thus:</p>
<p>$$
\begin{eqnarray}
\sum_{i = 1}^n w_i(|x - p_i| - |p - p_i|) &amp;&gt;&amp; (p - x)\sum_{p_i &gt; p}w_i + (x - p)\sum_{p_i \leq p}w_i \\
&amp;=&amp; (x - p)(\sum_{p_i \leq p}w_i - \sum_{p_i &gt; p}w_i)
\end{eqnarray}
$$</p>
<p>Because $\sum_{p_i \leq p}w_i &gt; \frac{1}{2}$ and $\sum_{p_i &gt; p}w_i &lt; \frac{1}{2}$, so $(x - p)(\sum_{p_i \leq p}w_i - \sum_{p_i &gt; p}w_i) &gt; 0$.</p>
<p>So for any point x other than p we have $f(x) &gt; f(p)$, so the weighted median is the best solution.</p>
<h3 id="e">e</h3>
<p>We need to find a point p(x, y) such that $\sum_{i = 1}^n w_i(|x - x_i| + |y - y_i|)$ is minimum. Because $\sum_{i = 1}^n w_i(|x - x_i| + |y - y_i|) = \sum_{i = 1}^n w_i|x - x_i| + \sum_{i = 1}^n w_i|y - y_i|$, the problem is actually 2 1-dimensional problems. Thus let x be the weighted median of all x coordinate values, and let y be the weighted median of all y coordinate values, so p(x, y) is the best solution.</p>
<h2 id="9-3">9-3</h2>
<h3 id="a_2">a</h3>
<p>If $i \geq \frac{n}{2}$, then we use the <code>SELECT</code> algorithm, otherwise we group every two elements into pairs $(a_j, b_j)$ and make sure $a_j \leq b_j$, if n is odd, we also let the last element be a pair, this step needs $\lfloor \frac{n}{2} \rfloor$. So now we have $\lceil \frac{n}{2} \rceil$ pairs. Then we recursively call the algorithm on $a_j$, so we can get the ith smallest element of all $a_j$, this step requires $U_i(\lceil \frac{n}{2} \rceil)$. Notice that the partition method partition all $a_j$ into two parts, so the ith smallest element of all elements could only be among $a_1\ldots{a_i}$ and $b_1\ldots{b_i}$. Then we run the <code>SELECT</code> algorithm on the 2i elements to find the ith smallest element.</p>
<pre><code>SMALL-ORDER-STATISTICS(A, i)
if i &gt;= n / 2
    return SELECT(A, i)
let pairs be a new array
for i = 1 to n with step = 2
    if i + 1 &lt;= n
        if A[i] &lt;= A[i + 1]
            insert [A[i], A[i + 1]] into pairs
        else
            insert [A[i + 1], A[i]] into pairs
    else
        insert [A[i]] into pairs
SMALL-ORDER-STATISTICS(pairs, i) // Run algorithm on all aj
return SELECT(pairs, i) // Run algorithm on a1 to ai plus b1 to bi
</code></pre>

<h3 id="b_2">b</h3>
<p>Let's solve by the substitution method. We start by assuming that $U_i(n) = n + O(T(2i)\lg(\frac{n}{i}))$ holds for all positive m &lt; n, in particular for $m = \lceil \frac{n}{2} \rceil$, yielding $U_i(\lceil \frac{n}{2} \rceil) = \lceil \frac{n}{2} \rceil + O(T(2i)\lg(\frac{\lceil \frac{n}{2} \rceil}{i}))$. Substituting into the recurrence yields:</p>
<p>$$
\begin{eqnarray}
U_i(n) &amp;=&amp; \lfloor \frac{n}{2} \rfloor + \lceil \frac{n}{2} \rceil + O(T(2i)\lg(\frac{\lceil \frac{n}{2} \rceil}{i})) + T(2i) \\
&amp;=&amp; n + O(T(2i)\lg(\frac{\lceil \frac{n}{2} \rceil}{i})) + O(T(2i)) \\
&amp;=&amp; n + O(T(2i)(\lg(\frac{\lceil \frac{n}{2} \rceil}{i}) + 1)) \\
&amp;=&amp; n + O(T(2i)(\lg(\frac{\lceil \frac{n}{2} \rceil}{i}) + \lg2)) \\
&amp;=&amp; n + O(T(2i)\lg(\frac{n}{i}))
\end{eqnarray}
$$</p>
<h3 id="c_2">c</h3>
<p>If i is a constant, and because $T(n) = O(n)$, so T(2i) = O(2i), so T(2i) is also a constant, and $O(\lg{\frac{n}{i}}) = O(\lg{n})$. Thus $U_i(n) = n + O(T(2i)\lg(\frac{n}{i})) = n + O(\lg{n})$.</p>
<h3 id="d_1">d</h3>
<p>It's so obvious, we just replace i with $\frac{n}{k}$ and yields $U_i(n) = n + O(T(2i)\lg(\frac{n}{i})) = n + O(T(2\frac{n}{k})\lg(\frac{n}{\frac{n}{k}})) = n + O(T(\frac{2n}{k})\lg{k})$.</p>
<h2 id="9-4">9-4</h2>
<h3 id="a_3">a</h3>
<p>$z_i$ and $z_j$ are compared if and only if the first element to be chosen as a pivot from $Z_{ijk}$ is either $z_i$ or $z_j$. And the range of $Z_{ijk}$ depends on k. So:</p>
<p>$$
\begin{eqnarray}
E[X_{ijk}] &amp;=&amp;
    \begin{cases}
      \frac{2}{j - k + 1} &amp; \text{if } k \leq i &lt; j \\
      \frac{2}{j - i + 1} &amp; \text{if } i &lt; k \leq j \\
      \frac{2}{k - i + 1} &amp; \text{if } i &lt; j &lt; k
    \end{cases}
\end{eqnarray}
$$</p>
<h3 id="b_3">b</h3>
<p>$$
\begin{eqnarray}
E[X_k] &amp;=&amp; \sum_{i = 1}^{n - 1}\sum_{j = i + 1}^n E[X_{ijk}] \\
&amp;=&amp; \sum_{i = k}^{n - 1}\sum_{j = i + 1}^{n} E[X_{ijk}] + \sum_{i = 1}^{k - 1}\sum_{j = k}^{n} E[X_{ijk}] + \sum_{i = 1}^{k - 2}\sum_{j = i + 1}^{k - 1} E[X_{ijk}] \\
&amp;=&amp; \sum_{i = k}^{n - 1}\sum_{j = i + 1}^{n} \frac{2}{j - k + 1} + \sum_{i = 1}^{k - 1}\sum_{j = k}^{n} \frac{2}{j - i + 1} + \sum_{i = 1}^{k - 2}\sum_{j = i + 1}^{k - 1} \frac{2}{k - i + 1} \\
&amp;=&amp; 2(\sum_{i = k}^{n - 1}\sum_{j = i + 1}^{n} \frac{1}{j - k + 1} + \sum_{i = 1}^{k - 1}\sum_{j = k}^{n} \frac{1}{j - i + 1} + \sum_{i = 1}^{k - 2}\sum_{j = i + 1}^{k - 1} \frac{1}{k - i + 1}) \\
&amp;=&amp; 2(\sum_{i = k}^{n - 1}\sum_{j = i + 1}^{n} \frac{1}{j - k + 1} + \sum_{i = 1}^{k - 1}\sum_{j = k}^{n} \frac{1}{j - i + 1} + \sum_{i = 1}^{k - 2} \frac{k - i - 1}{k - i + 1}) \\
&amp;=&amp; 2(\sum_{i = k}^{n - 1}\sum_{j = i + 1}^{n} \frac{1}{j - k + 1} + \sum_{i = 1}^{k}\sum_{j = k}^{n} \frac{1}{j - i + 1} - \sum_{j = k}^n \frac{1}{j - k + 1} + \sum_{i = 1}^{k - 2} \frac{k - i - 1}{k - i + 1}) \\
&amp;=&amp; 2(\sum_{i = 1}^{k}\sum_{j = k}^{n} \frac{1}{j - i + 1} + \sum_{i = k}^{n - 1}\sum_{j = i + 1}^{n} \frac{1}{j - k + 1} - \sum_{j = k}^n \frac{1}{j - k + 1} + \sum_{i = 1}^{k - 2} \frac{k - i - 1}{k - i + 1})
\end{eqnarray}
$$</p>
<h3 id="c_3">c</h3>
<p>We have $\sum_{i = 1}^{k}\sum_{j = k}^{n} \frac{1}{j - i + 1} \leq n$ (<a href="https://math.stackexchange.com/questions/529208/inequality-sumk-i-1-sumn-j-k1-overj-i-1-le-n">source</a>), and $\sum_{k + 1}^n \frac{j - k - 1}{j - k + 1} + \sum_{i = 1}^{k - 2} \frac{k - i - 1}{k - i + 1} &lt; \sum_{k + 1}^n 1 + \sum_{i = 1}^{k - 2} 1 = n - k + k - 2 = n - 2 &lt; n$, so $E[X_k] \leq 2(n + n) = 4n$.</p>
<h3 id="d_2">d</h3>
<p>Since $E[X_k] \leq 4n$, thus $T(n) = O(n)$.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../10-Elementary-Data-Structures/10.1-Stacks-and-queues/" class="btn btn-neutral float-right" title="10.1 Stacks and queues">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../9.3-Selection-in-worst-case-linear-time/" class="btn btn-neutral" title="9.3 Selection in worst-case linear time"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../9.3-Selection-in-worst-case-linear-time/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../10-Elementary-Data-Structures/10.1-Stacks-and-queues/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
