# 9.1 Minimum and maximum
## 9.1-1
We know that we need n - 1 comparisions to find the smallest element. Let's define an algorithm to find the smallest element:

```
FIND-THE-SMALLEST(A, low, high)

mid = (low + high) / 2
left-min = FIND-THE-SMALLEST(A, low, mid)
right-min = FIND-THE-SMALLEST(A, mid + 1, high)
return min(left-min, right-min)
```

The root node of the recursive tree has two children, one of them is the smallest element, let's assume the left child is the smallest element and let k denote the right child, then in order to find the second smallest element, we can traverse through the left branch and compare the smaller element in each node with k, if we find a element that is smaller than k, then that element is the second smallest element, else k is the second smallest element.

Because we only compare the smaller element with k in each node, so we don't need to traverse all branches in left branch, the worst-case happens when the second smallest element in the left branch is larger than k. Since the height of recursive tree is $\lceil \lg{n} \rceil$, thus we need $\lceil \lg{n} \rceil - 1$ comparisions. So we need $n - 1 + \lceil \lg{n} \rceil - 1 = n + \lceil \lg{n} \rceil - 2$ comparisions.

## 9.1-2
